# Apr 13
- 按照实验指导书配置环境
- 阅读课本第 0 章

# Apr 14
## 操作系统抽象 
- 异常控制(Concurrency)
    - 中断：外设引起的外部事件中断，是异步的，与处理器无关
    - 异常：处理器执行指令时检测到的非法事件，处理器主动异常处理或直接终止
    - 陷入：程序通过系统调用请求操作系统而有意引发的事件
- 进程 Process(Concurrency, Virtualization)
    - 进程是应用程序的一次执行过程，在执行过程中，由“操作系统”执行环境来管理程序执行过程中的进程上下文。
    - 一个进程是一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程
- 地址空间(Viratualization)
- 文件(Persistency)
    - 文件是持久存储的抽象，并进一步扩展为外设的抽象（一切皆文件）
    - 为什么外设抽象为文件，而不是内存
## 操作系统的特征
- 虚拟性
    - 内存虚拟化，是一种空间虚拟化，可以分为内存地址虚拟化和内存大小虚拟化
        - 内存地址虚拟化：编译器设定固定地址，通过操作系统放到闲置物理内存中，实现内存地址虚拟化
        - 内存大小虚拟化：操作系统将物理内存中没有使用的空间换出，写到硬盘当中，实现内存大小虚拟化（swap）
    - CPU 虚拟化
- 并发性：改善系统资源利用率，但是带来对共享资源的争夺问题
    - 并行：两个或多个事件在同一时刻发生
    - 并发：两个或多个事件在同一时间间隔内发生
- 异步性：由于操作系统的调度和中断，会不时地暂停或打断当前正在运行的程序    
- 共享性：并发运行是，对资源的共享访问。需要在操作系统乃至于硬件层次上的一致性
- 持久性：文件系统将存储介质中的数据读取到内存中，并可以把内存中的数据写回到存储介质中

## 练习
### 编程题

### 问答题
1. 操作系统是向下管理硬件资源，向上提供应用的软件。目的是对硬件资源作合理抽象，提供给用户
2. 服务器操作系统注重并发性，手机操作系统注重持久性
3. 面向用户的操作系统必须包括网络浏览器，因为信息交互是用户使用操作系统的首要原因
4. 虚拟化：内存，CPU；并发性：CPU；异步性：CPU；共享性：存储介质，内存；持久性：存储介质
5. 内存和文件系统
6. 对资源（空间：内存，硬盘，时间：CPU，并发）的抽象
7. C 可以直接操作内存，Java 需要基于虚拟机
8. 通过操作系统同一抽象调用硬件。
    程序执行：thread
    内存分配：malloc
    文件读写：io
9. 
10. 单个OS：；批处理OS；多道程序OS；分时共享OS；

# Apr 16
- 计算机组成原理
    - 计算机主要由 CPU、物理内存、I/O 外设组成
    - CPU 从物理内存中读取指令、译码并执行，可能会与物理内存和 I/O 打交道
    - 物理内存 是计算机重要组成，CPU 唯一能够直接访 问的只有物理内存中的数据，CPU 将物理内存视为大字节数组，CPU 可以通过物理内存寻址，并逐字节地访问物理内存中保存的数据
- Qemu
- 指令
```shell
qemu-system-riscv64 \

    -machine virt \

    -nographic \

    -bios ../bootloader/rustsbi-qemu.bin \

    -device loader,file=target/riscv64gc-unknown-none-elf/release/os.bin,addr=0x80200000
```
- 指令介绍
    - ``-machine`` 计算机名
    - ``-nographic`` 无图形界面
    - ``-bios`` 初始化引导
    - ``-device`` ``loader`` 将 Qemu 模拟器开机之前将一个宿主文件载入到 Qemu 物理内存的指定位置当中
- Qemu 启动流程
    - 第零阶段：物理内存起始地址：``0x80000000``，课程使用范围为 ``[0x80000000,0x80800000]``，使用之前指令启动时，首先会将 bootloader 的 ``rustsbi-qemu.bin`` 加载到 ``0x80000000`` 上，接着将内核镜像加载到 ``os.bin`` 加载到 ``0x80200000`` 上
    - 第一阶段：将必要的文件载入到 Qemu 物理内存之后，Qemu CPU 的程序计数器（PC, Program Counter）会被初始化为 ``0x1000`` ，因此 Qemu 实际执行的第一条指令位于物理地址 ``0x1000`` ，接下来它将执行寥寥数条指令并跳转到物理地址 ``0x80000000`` 对应的指令处并进入第二阶段。从后面的调试过程可以看出，该地址 ``0x80000000`` 被固化在 Qemu 中，作为 Qemu 的使用者，我们在不触及 Qemu 源代码的情况下无法进行更改。
    - 第二阶段：由于 Qemu 的第一阶段固定跳转到 ``0x80000000`` ，我们需要将负责第二阶段的 bootloader rustsbi-qemu.bin 放在以物理地址 ``0x80000000`` 开头的物理内存中，这样就能保证 ``0x80000000`` 处正好保存 bootloader 的第一条指令。在这一阶段，bootloader 负责对计算机进行一些初始化工作，并跳转到下一阶段软件的入口，在 Qemu 上即可实现将计算机控制权移交给我们的内核镜像 os.bin 。这里需要注意的是，对于不同的 bootloader 而言，下一阶段软件的入口不一定相同，而且获取这一信息的方式和时间点也不同：入口地址可能是一个预先约定好的固定的值，也有可能是在 bootloader 运行期间才动态获取到的值。我们选用的 RustSBI 则是将下一阶段的入口地址预先约定为固定的 ``0x80200000`` ，在 RustSBI 的初始化工作完成之后，它会跳转到该地址并将计算机控制权移交给下一阶段的软件——也即我们的内核镜像。
    - 第三阶段：为了正确地和上一阶段的 RustSBI 对接，我们需要保证内核的第一条指令位于物理地址 ``0x80200000`` 处。为此，我们需要将内核镜像预先加载到 Qemu 物理内存以地址 ``0x80200000`` 开头的区域上。一旦 CPU 开始执行内核的第一条指令，证明计算机的控制权已经被移交给我们的内核，也就达到了本节的目标。
- 真实计算机加电启动流程
    - 第一阶段：加电后 CPU 的 PC 寄存器被设置为计算机内部只读存储器（ROM，Read-only Memory）的物理地址，随后 CPU 开始运行 ROM 内的软件。我们一般将该软件称为固件（Firmware），它的功能是对 CPU 进行一些初始化操作，将后续阶段的 bootloader 的代码、数据从硬盘载入到物理内存，最后跳转到适当的地址将计算机控制权转移给 bootloader 。它大致对应于 Qemu 启动的第一阶段，即在物理地址 0x1000 处放置的若干条指令。可以看到 Qemu 上的固件非常简单，因为它并不需要负责将 bootloader 从硬盘加载到物理内存中，这个任务此前已经由 Qemu 自身完成了。
    - 第二阶段：bootloader 同样完成一些 CPU 的初始化工作，将操作系统镜像从硬盘加载到物理内存中，最后跳转到适当地址将控制权转移给操作系统。可以看到一般情况下 bootloader 需要完成一些数据加载工作，这也就是它名字中 loader 的来源。它对应于 Qemu 启动的第二阶段。在 Qemu 中，我们使用的 RustSBI 功能较弱，它并没有能力完成加载的工作，内核镜像实际上是和 bootloader 一起在 Qemu 启动之前加载到物理内存中的。
    - 第三阶段：控制权被转移给操作系统。由于篇幅所限后面我们就不再赘述了。
    - 值得一提的是，为了让计算机的启动更加灵活，bootloader 目前可能非常复杂：它可能也分为多个阶段，并且能管理一些硬件资源，从复杂性上它已接近一个传统意义上的操作系统。
- 程序内存布局
    - 可执行文件可以分为**代码**和**数据**两部分，代码由可被 CPU 解码并执行的指令组成，数据是被 CPU 视作可读写的内存空间
    - 程序的**内存布局**由不同功能的**段**组成
    - 代码：``.text`` 一个段
    - 数据
        - 全局数据段：只读 ``.rodata`` 读写 ``.data``
        - 未初始化数据段：``.bss`` 未初始化全局数据，程序加载者由零初始化，最终该区域逐字节清零
        - **堆**(heap)用于放置程序运行时分配的数据，向高地址增长
        - **栈**(stack)用作函数调用、上下文保存恢复、函数局部变量，向低地址增长
    - 函数视角（局部变量与全局变量）
        - 函数的输入参数与局部变量：保存在寄存器或栈帧当中，栈帧会通过栈指针加上偏移量访问
        - 全局变量：保存在 .data .bss 中，有时通过 gp 加上偏移量访问
        - 堆上的动态变量：本体保存在堆上，大小在运行时确定。但我们只能直接访问栈上或全局数据段上的**编译器确定大小**的变量，因此通过一个在编译时确定大小的指针（指针位宽编译器可知），该指针指向堆上的数据以访问。该指针可以作为局部变量保存在栈帧，也可以作为全局变量放在全局数据当中。
- 编译流程
    - 编译器(compiler)将源文件转化为汇编语言，源文件仍是文本文件
    - 汇编器(assembler)将每个源文件转化为机器码，得到一个二进制目标文件
    - 链接器(linker)将上一步得到的目标文件以及一些可能的外部目标文件链接在一起形成一个完整的可执行文件
    - 汇编器输出的每一个文件都有独立的程序内存布局，链接器则将所有输入目标文件整合成一个整体的内存布局，主要有两项工作
        - 第一件事情是将来自不同目标文件的段在目标内存布局中重新排布。
        - 第二件事情是将符号替换为具体地址。